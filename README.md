# Avery's ePortfolio

Welcome to Avery's ePortfolio. This ePortfolio contains three enhanced computer programs that I originally developed during my four years in Southern New Hampshire University's computer science program. These enhancements focus on exmeplifying my skills in software design and engineering, data structures and algorithms, and database management. Additionally, this ePortfolio contains an informal narrated code review and a professional self-assesment that discusses my experience in SNHU's computer science program and my artifact selections. Thank you for your time and I hope you enjoy my work.

## Table of Contents
1. Profesional Self-Assesment
2. Informal Code Review
3. Artifact One: Software Design and Engineering
4. Artifact Two: Data Structures and Algorithms
5. Artifact Three: Databases
6. ePortfolio Closing Statements

## 1. Profesional Self-Assesmenet
Since my acceptance into Southern New Hampshire University’s computer science program in August of 2018, I have had the privilege of developing over fifty unique applications in five distinct coding languages. Although my experience at SNHU has given me an opportunity to meet many students who were already well established in the field of computer science, the only experience I had writing code prior to joining this program came from an introduction class I took at the former university I attended. Therefore, every single class that I have taken over the past four years has shaped me into a programmer with efficient coding skills and a keen understanding on the importance of documentation. Throughout the completion of my SNHU coursework and during the development of my computer science ePortfolio, I have gained numerous skills that will carry me forward into my future professional endeavors. Being able to make quick yet well calculated decisions, think critically about the overarching functionality of my work, and explain high-level concepts to audiences of varying experience are just three of the skills that will significantly benefit my success in any career that I may choose to pursue. 

With each assignment that I have submitted leading up to the final portfolio, I have been able to effectively showcase my talents as a software developer in terms of the quality and complexity of the work that I deliver. These talents are clearly demonstrated in my capabilities in software design and engineering. In February of 2022, I was tasked with developing a C++ dice game named Left Center Right for the final project of my IT-312: Software Development with C++.Net course. This game was a simple text-based game in which a random number generator was utilized to simulate a rolling die and then an action to correspond with each possible value result was displayed to the user. Throughout the entire IT-312 course, the completion of weekly labs that examined properly declaring data types, implementing basic arithmetic, and reading from text files acted as the foundation to the sills that would be required for the final dice game submission. The completed dice game successfully incorporated three classes to distinguish different mechanics required for the game’s functionality, creative dialog to maintain the user’s engagement, and ten methods that organized the main program components. 

This program was selected to represent artifact one within the portfolio due to the innovative techniques and creative nature that already existed within the game. Taking the opportunity to transfer the C++ text-based game into a fully interactive mobile application showcased my skills in software design and engineering through the implementation of more robust code, the utilization of industry-standard practices, and the incorporation of diverse gameplay mechanics. I was able to take basic components of the original project and implement advanced techniques that scaled the simple text-game to an application that is of professional standards. For example, the ability to read from a text file to display instructions transformed into the development of an “Instructions” screen that exists as its own unique Java activity that utilizes a scrollbar for easy navigation. Asking the user to input a “y” or “n” as an answer to whether or not they were ready for their turn was transformed into a button that allows users to simply “roll” whenever they choose. Even the utilization of diverse image placement that changes with each player’s turn showcases an exemplary understanding of software design and engineering.


## 2. Informal Code Review.

In this informal code review, the three artifacts that were selected for enhancmet are examined and critiqued in terms of their current functionality, organization, and complexity. The code for each artifact is analyzed in detail in order to ensure that areas for improvement are highlighted. Then the planned enhancement for each program is discussed. This code review is approximately forty minutes in length. 
Please click the provided link to view: [Avery's Code Review](https://www.youtube.com/watch?v=6nJdgMT_BmY).

## 3. Artifact One: Software Design and Engineering

### Artifact One Links
To see the drastic improvements that have been made to the quality of the artifact one program, it may be beneficial for some to compare the original version of the program and the final program enhancements. The project has seen significant upgrades in terms of visual appeal, interactive components, and communications with the user. Therefore, both the original code and enhanced program are linked below.
 
Click to view the **original C++ program** prior to enhancment: [LCR Original Code](https://github.com/averylutz123/Artifact_One_Original).

Click to view the **enhanced artifact one program** that represents skills in software design and engineering: [Artifact One: LCR Enhancements](https://github.com/averylutz123/Artifact_One_Enhancement).

### Artifact Description
The artifact that has been selected to represent skills in software design and engineering was derived from the final project that was created within IT-312: Software Development with C++.Net titled Final Project 7-1: Dice Game. Originally developed in February of 2022, this program showcases a fully functional text-based game named Left Center Right (LCR) in which users take turns “rolling the dice” to see who can obtain and maintain the greatest number of gameplay chips. In order for the program to achieve total functionality, ten unique methods were utilized to distinguish the different gameplay mechanics such as rolling the dice and passing the chips. Additionally, three classes were implemented to represent the program components that were associated with the player, dice options, and game features. Because the contents of the LCR game prior to the artifact’s enhancements were confined to the text dialog within the console output, the program ensured that any potential user input was accounted for so that the game could appropriately communicate no matter what the user entered.  
	
 While the LCR program was initially developed with the C++ programming language, the enhancement for this artifact focused on transferring the code into a Java mobile application. This transfer to a different language has enabled the program to become a more interesting and interactive gaming experience that is more consistent with professional computer science standards. Colorful imagery, interactive buttons, multiple screens with diverse layouts, and new dialog options were applied within the Java mobile application to improve user engagement and to increase the desire for participants to replay the game multiple times. Therefore, the transfer of the LCR program into a Java mobile application resulted in the utilization of innovative skills and the implementation of design solutions that ensured a higher quality product was delivered upon completion. 

### Artifact Justification 
The LCR program was selected to represent artifact one within the capstone portfolio due to the potential that the original application possessed for becoming a genuine mobile game that could be uploaded to the app store and played by the general public. The original version of the program merely existed as text dialog within the C++ console output in which the users and the game would communicate through a basic exchange of information. However, since the logic and instructions for the game are quite simple to understand, the program was an ideal platform for showcasing exceptional enhancement skills during the reconstruction of the artifact into a comprehensive final product. Additionally, the utilization of methods to separate different gameplay mechanics within the original LCR program provided a solid foundation for creating different screens that users could navigate through within the mobile application. Similarly, it was clear that the utilization of widgets in the mobile application, such as buttons, would offer a more natural transition between the various gameplay mechanics as opposed to the pre-existing functionality of accepting the user’s input to progress forward. Therefore, the LCR program provided an excellent opportunity for demonstrating skills in software design and engineering. 

### Demonstrated Skills and Abilities
Within the artifact one enhancement, the ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals was effectively demonstrated. The implementation of more robust and efficient controls can be seen in the removal of the three classes that existed within the original version of the program and the replacement of these classes with calls to the Android specific Intent class. The three original classes were removed due to the minimal impact they had on the program’s performance that resulted in needless repetition, wasted space, and redundant variable declarations. Calls to the Intent class to pass data between each Java activity within the mobile application not only provided easier readability of the code, but also minimized the steps required for each gameplay mechanic to obtain total functionality. 
 
Another innovative feature that was implemented to minimize redundancy and to improve the efficiency of the program can be seen in the button widget that was incorporated into the CalculateRollsActivity.java file. Within this activity, an if-else statement is utilized to determine whether a user has enough chips (a value greater than zero in the point tracker array) to progress forward into the next activity. Then, a single button is displayed to indicate that the user may “roll” the dice or “skip turn” by setting the text of the button to the designated response in the corresponding if-else statement branch. Likewise, each branch has a corresponding call to the intent class that will send the user back to the score board so that the next player may begin their turn or allow the current player to progress forward and roll the dice. By utilizing this technique to advance the game forward, the number of required Java activities, widgets, and methods is minimized. Thus, industry-standard software designs were implemented into the program and the ability to utilize well-founded and innovative techniques, skills, and tools in computing practices was further demonstrated.
 
The last significant indicator for exhibiting the ability to utilize well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals can be seen in the effective organization of loops and branches that ensure smooth iterations between array elements. These iterations show exceptional skills in array handling to test the user’s input and to test the qualifications of each player until a winner is declared. For example, the program successfully iterates through the point tracking array to correctly determine when a single player element has a value equal to the total value of in-game chips. Additionally, the point tracking array and players’ names array needed to be passed between activities in order to correctly track the names of each player during every round and the number of chips distributed between all participants. The culmination of these skills resulted in the development of a program that successfully demonstrates an exemplary understanding of software design and engineering. 

### Enhancements
1. Nine of the ten original methods that existed within the C++ version of the game were transferred to the Java programing language. These methods now exist in the form of new methods that spread throughout the entirety of the program or as individual Java activities. The politeQuestion method was not included within the enhancements of the artifact since users were no longer required to enter text dialog to progress forward and thus unexpected responses did not need to be accounted for. 
2. Ten new Java activities were created to represent the different screens users will navigate through.
3. Ten new xml files were created to provide a clean and organized layout for each screen the users will interact with.
4. Fourteen new drawable png files were imported into the program to be utilized as imagery.
5. The strings xml file was updated to include forty new string values that are called throughout the program.
6. A new functional component was created to read from an external text file to display text discussing the creation and purpose of the game titled “About.”
7. A new method was developed that displays three different images each time a player “rolls” and the method is called. An if-else statement is utilized to select from six drawable options or the default image is utilized. 
8. Scroll bars were implemented in five xml layout files so users can move up and down the screen when required to continue reading text that is not visible upon the activity start.
9. Ten buttons were implemented as a mechanism for users to progress further into the game.
10. A new feature was added that instructs players on the order in which they should be sitting so that the chip passes are accurate to their real-life seating arrangement. 
11. Removed program content, such as the three unnecessary classes, that resulted in redundancy, repetition, and inefficient.
12. Improved comments within the code to correctly describe the purpose of major segments. 
13. Ensured formatting throughout each activity and xml file was well-structured, consistent in style, and consistently formatted.
14. Ensured code was error free. 

### Objectives
Throughout the enhancement of artifact one, all corresponding objectives that had been planned prior to development were fully met and the expectations of these objectives have been exceeded. Within artifact one, innovative skills and techniques for implementing design solutions and accomplishing goals are demonstrated in the logical breakdown of each activity into clear segments of functionality. None of the individual program activities or methods are needlessly complex or contain content that extends past their intended purposes. For example, the CalculateRollsActivity.java file strictly exists to determine the number of rolls allotted to each player and to display the computed value onto the screen for users to read. Determining which activities, or screens, should be incorporated into the project also required creative decision making as the original version of the program had no such need for this level of  organization since the contents of the program were only displayed in the console output. 

### Reflection 
Throughout the process of enhancing the LCR artifact, I learned the importance of focusing on big picture concepts instead of only fixating on little details. While the entirety of the final program is in fact comprised of little details that each needed to obtain total functionality, trying to perfect a single feature before the majority of the project exists can take time away from forming a cohesive and uniform product. Therefore, I learned that breaking down the broad goals of the project into various tasks based on functionality allowed me to build the program up in layers. For example, when creating a new activity, the first thing that needed to be accomplished was laying out the basic framework for the necessary widgets within the xml file without thinking about details such as fonts, placement, or color. Then, each widget was linked to the necessary functional components within the java file in which new methods would be added in order of importance. Then, the last step is to make the entire activity look visually appealing on the screen by adjusting colors and importing pictures. In this enhancement I learned that the little details of the project are absolutely important, however, they provide few benefits when other sections of the program are inadvertently being overlooked. 
	
The biggest challenge that I faced while developing this artifact was relearning how to work within Android Studio. My experience with the IDE is quite minimal since I had only ever created a handful of small mobile application during my time in CS-360 in December of 2021. In fact, I had not worked with Java in a meaningful way since that course had ended, so the initial days of working on the LCR program revolved around learning basic concepts such as placing widgets, linking xml and java file contents, and applying functionality to widgets within each activity. Even objectives that I typically excel in accomplishing, such as reading from external text files, seemed more complicated in the mobile application format since the contents of the xml file always had to be considered with every decision. However, despite this challenge, the completed application turned out to be an enjoyable and well-designed product.
	
The feedback for this artifact with its original submission was to improve the manner in which I discuss the course outcomes within the narrative. Specifically, I originally mentioned that I met all objectives, but I needed to identify and articulate which outcomes I met within the enhancement. Therefore, I changed the formatting of my narrative to specifically discuss how the artifact was improved in terms of the main skill that was exhibited: using well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals. I created a clear header for this section of my narrative titled “Demonstrated Skills and Abilities,” and stated the skill at the beginning of the first paragraph. I also incorporated some of the indicators of success to ensure my accomplishments were more obvious. 


## 4. Artifact Two: Data Structures and Algorithms

### Artifact Two Links
Throughout the enhancement of artifact two, significant improvements were made in program functionality, code readability, and user engagement. Therefore, it may be beneficial to review the original contents of artifact two in order to truly vizualize the strides that were made in strengthening the program's overall quality and efficiency. Both links to the original version of artifact two as well as the enhancement are linked below.

Click to view the **original data structure portfolio** prior to enhancment: [Data Structure Original](https://github.com/averylutz123/Artifact_Two_Original).

Click to view the **enhanced artifact two program** that represents skills in data structures and algorithms: [Artifact Two: Data Structure Enhancements](https://github.com/averylutz123/Artifact_Two_Enhancement).

### Artifact Description
The program that was selected to represent artifact two within the series of enhancements that were completed for this portfolio was the 7-1 Final Project Portfolio from CS-260: Data Structures and Algorithms. Originally developed in February of 2020, this C++ portfolio features four separate programs that highlight the main differences and benefits of some of the most commonly utilized data structures. Binary search trees, hash tables, linked lists, and vectors are each implemented in their own distinct programs where they allow users to navigate through two Microsoft Excel files that contain information pertaining to the bidding statistics of items that were submitted during an auction of property. These programs allowed users to select from a menu of options in which they could originally display the bids, search for a specific bid, or remove bids after the contents of the Excel file had been read. Additionally, the vector sorting program allowed users to complete a quick sort or selection sort in order to place the list of auction items in alphabetical order. Although the goals of the four portfolio programs were similar in terms of their intended purposes, due to the differences in the implemented data structures and algorithms, each program utilized unique techniques to obtain total functionality. 

### Artifact Justification 
The 7-1 Final Project Portfolio from CS-260 was selected to represent artifact two with the enhancement strategy focused on algorithms and data structures due to the exceptional utilization of data management practices within each of the four programs. Because the project itself was designed with the intention of demonstrating the advantages of various data structures and algorithms, it was an ideal candidate for exhibiting skills in implementing  algorithmic principles, computer science practices, and computing standards to solve existing problems within the code. Additionally, the state of the programs prior to enhancement left ample room for improvements since the original functional goals of the project were fundamentally related to the computer programming CRUD operations (create, read, update, delete). However, since the programs were only designed to read and delete bids within the list of items, the logical improvement that could be made to the code was to include the ability to add and update user specified bids as well.

### Demonstrated Skills and Abilities
Within the artifact two enhancements, the skill of designing and evaluating computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices, was demonstrated. This skill was exemplified in the development of the new “update” and “create” methods that were incorporated into each program to solve the project’s previous shortcomings in obtaining total CRUD functionality. With the inclusion of these methods, each program can now successfully create, read, update, and delete information within the specific data structure that exists in each program. Since the approach utilized to navigate through each of the four data structures vastly differ from one another, it was essential for structure specific techniques to be implemented within each program. For example, the hash table program required the implementation of a node pointer, bid key, and while loop to update the contents of an existing bid whereas the vector sorting program only required the vector element value for the bid in question. Therefore, determining the appropriate strategy for each program required an in-depth knowledge and an excellent ability in evaluating computing solutions for logic problems. 

The skill of designing and evaluating computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution was also demonstrated in the advancements made to the user menu. Prior to enhancement, the menu-controlled switch statement’s lack of communication with users alongside the code’s inability to steer users into selecting appropriate menu options often times resulted in inaccurate selections or complete failure in functionality. Now, a default option exists so that unacceptable inputs are appropriately handled, and the user is directed to try again. Similarly, logic problems that existed within the original “search” and “remove” methods have been resolved by providing users the ability to input their own unique bid IDs. Originally, the program only allowed the “default key” to be searched for and removed, thus, the entire application only existed to manage one bid out of the minimum of 179 that exist in the Excel file. By highlighting logical problems seen within the user menu and implementing appropriate measures to improve interactivity and cooperation between those utilizing the program and the fictitious municipal government data feed that obtained the list of bids, the program is able to accomplish 
a greater variety of tasks in a more efficient manner.

Within the artifact two enhancements, the skill of developing a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources was clearly demonstrated. This skill is highlighted in the improvements made to every case within each program’s main menu switch statement and the value checks that were implemented in several methods. Beyond the new default option that was incorporated into the switch statement to support the functionality of the menu, multiple if statements were implemented to act as safeguards in assuring that bids are loaded prior to being manipulated. Now, if a user selects an option other than “Load Bids” as their first course of action upon loading the program, the user is informed that they must load the bids before progressing forward. 

Another example of a security mindset being demonstrated throughout the enhancement of artifact two can be seen in the incorporated value checks that ensure bids exist prior to the completion of any CRUD activities. Now, users of the program can access complete and correct data without causing errors to occur since numerous if statements have been incorporated to examine whether or not a requested bid ID exists within the program’s specific data structure. If the bid ID does not exist, the expected CRUD activity does not occur, and the user is informed that the action could not be completed. Thus, all data is validated to ensure the program can run until the user decides to exit the application. Likewise, ten warnings existed within the program prior to enhancement that expressed potential vulnerabilities within the application that could be exploited. For example, five “comparison between signed and unsigned expressions” warnings were given in the Vector Sorting program at different for loops. With these warnings, and without proper variable declarations, many for loops had the potential to return incorrect and unaccepted values. In resolving these issues, a coding environment with clear communications and efficient navigation without easily exploitable vulnerabilities was cultivated. 

### Enhancements 
1. Included two new cases within the menu switch statement in the BinarySearchTree.cpp, HashTable.cpp, LinkedList.cpp, and VectorSorting.cpp programs. These new cases center on the creation of new bids and the ability to update existing bids. 
2. Included an additional case in the VectorSorting.cpp program to delete existing bids.
3. Added a default case within the menu switch statement in all four programs. Now unexpected user inputs are accounted for.
4. Included an if-else statement within five of the cases of each program’s menu switch statement to ensure all bids have been loaded prior to completing any further actions. These if-else statements act as a safeguard to ensure the CRUD tasks can be completed and to prevent the program from experiencing debilitating errors. 
5. Incorporated an “update” method within each program. These methods successfully examine the contents of each program’s corresponding data structure, locates the bid in question, and accepts the user’s input to change specific data members within the structure.
6. Implemented safeguard measures within each “update,” “delete,” and “search” method to ensure unexpected user inputs are accounted for and to direct users back to the main menu when necessary.
7. Incorporated a “createBid” method within the BinarySearchTree.cpp and HashTable.cpp programs. This method accepts three user inputs and formats their inputs into appropriate data members. The method then appends the newly created bid to the end of the existing list of bids.
8. Implemented a means for user-specified bids to be searched for and removed from each program’s particular data structure. Originally, the program’s depended on a single default bid and did not accept the user’s input. 
9. Reformatted and added new comments to create a more professional program that clearly communicats the contents of each method, switch statement case, and data structure modifications. 
10. Created a “delete” method within the VectorSorting.cpp program that accepts an input from the user and then erases the designated bid from the existing list in the bids vector.
11. Removed all program warnings that resulted in logic problems that had the potential to cause errors to occur.
12. Utilized data structure specific techniques to handle data appropriately in each program and ensured coding best practices were being followed. 

### Objectives 
Throughout the enhancement of artifact two, all corresponding objectives that had been planned prior to development were fully met and the expectations of these objectives have been exceeded. Within the enhancements of artifact two, a security mindset that anticipates adversarial exploits in software was exhibited and computing solutions that solve a given problem using 
algorithmic principles and computer science practices and standards appropriate to its 
solution were implemented. The entirety of each program was reformatted so that the code is complete and correct in design, the code is well-structured, consistent in style, and consistently formatted, and each method is written to be as efficient as possible. The enhancement of this artifact transformed a simple program with minimal functionality into an application that allows for professional-quality user engagement and an extensive list of features. 

### Reflection 
While working on the enhancements to artifact two, it was important to consider how the new additions to the project would impact the functionality of existing methods since each program had well over three hundred lines of code. Any changes to the main method of each program had the potential to significantly influence method calls, variable assignments, or points of termination in any existing loops. Therefore, frequently testing the output of the original features in the program in addition to the new enhancements within the code became an essential factor in delivering a correct, complete, and error-free artifact. Through this testing, I learned how to properly utilize the debug feature within Eclipse since none of the projects I have previously completed within the IDE required its assistance. I have not worked in Eclipse in almost two years as many of my C++ programs are created in Visual Studio, so overcoming the differences in their window formatting, perspective, and the debugging feature was quite a challenge. While both IDEs exist for the purpose of aiding programmers in developing their code, understanding the little variations between both environments really benefited the quality of the delivered artifact.  

Completing the enhancements to this artifact also gave me a better understanding on how to correctly implement pointers since they are something I typically try to avoid them in my work. While I am educated on the benefits of pointers and how they are utilized within a program, I have always found them to be a bit convoluted since I usually focus on a program’s functionality in terms of the literal code being written and not the memory spaces in which the variables, data members, and vector elements are being stored. In general, pointers seemed like such an abstract concept to me because they require an understanding of the program beyond what could be seen in the console output. Therefore, learning how to correctly utilize pointers was the greatest challenge I faced while working on artifact two’s enhancements because their incorporation played such a vital role in navigating throughout many of the data structures. Having existing program methods that also utilized pointers was incredibly beneficial in learning their correct implementation as I got to make changes to these existing features and see how it impacted the  output of the program. In future programs,  I will be less hesitant in utilizing pointers as they provided such a massive benefit in the efficiency in the artifact two enhancements. 

After submitting the first version of artifact two’s enhancements, I received feedback regarding the quality of my narrative. Specifically, I was asked to remove any “I believe” and “I think” statements. With the completion of the final enhancements, my narrative has been improved so that the skills and abilities exhibited throughout my work are discussed in a manner that is confident and unopinionated. Additionally, since the original submission, I made the decision to increase the functionality of the VectorSorting.cpp program to include a “delete bid” feature. This enhancement was not included with in my original plans, however, it seemed necessary to include so that all four programs are cohesive in expectations and style. Additionally, the incorporation of a “delete” feature in the VectorSorting.cpp program ensured all CRUD functionalities existed across all four programs without any exceptions. 


## 5. Artifact Three: Databases

### Artifact Three Links

Click to view the **original Event Tracker** prior to enhancment: [Event Tracker Original](https://github.com/averylutz123/Artifact_Three_Original).

Click to view the **enhanced artifact three program** that represents skills in database management: [Artifact Three: Databases](https://github.com/averylutz123/Artifact_Three_Enhancement).

### Artifact Description
In order to demonstrate expertise in the computer science skill of database management, the 7-1 Final Project: Event Tracker from CS-360: Mobile Architecture and Programming was selected as the category’s artifact for enhancement. Developed in December of 2021, this Java mobile application was designed to offer users a platform to store information related to future events they will be attending and notifying the users via text message when a new event was entered into the program’s database. The original functional components of the program included a login screen that ensured users were only accessing events that corresponded to their unique username and password, the ability to edit and delete event information after the event had been saved into the database, and the ability to send an SMS notification if the users granted the program permission to accomplish the task. The success of these functional components heavily relied on the program’s SQLite database which was comprised of three distinct tables that represented the user accounts, the list of events that corresponded to specific user accounts, and information associated with each individual event. Through the implementation of the SQLite database, the program was able to effectively allow multiple users to store the details of events in a uniform location without scrambling the contents of each account.  

### Artifact Justification 
The CS-360 Event Tracker mobile application was selected as the artifact to represent the category of database enhancements due to the significant role that the SQLite database plays in ensuring complete and correct functionality of the program. Because storing user and event information was foundational to accomplishing the functional goals that were initially set out for the program, the application would not be able to exist without the proper implementation of the database. Therefore, as an incorporation into a portfolio that is intended to showcase vital areas of expertise as a computer science professional, the Event Tracker was undoubtedly the most fitting example of admirable database management capabilities. Furthermore, the original version of the application had broad expectations that left ample room for the integration of innovative and more advanced features. When selecting this artifact to be included within the ePortfolio, it was apparent that the addition of several new features would bring the entirety of the Event Tracker mobile application to a greater professional standard. 

### Demonstrated Skills and Abilities
Within the artifact three enhancements, the ability to employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science was demonstrated. Within the enhancement of the Event Tracker artifact, existing in-code comments were improved upon in order to provide easily readable and understandable code to those who may examine the program. The original comments left within the program were ill-formatted and did not contain enough details for diverse audiences to understand the contents of the code. Additionally, in some portions of the program, entire methods and Java activities were left uncommented, thus, no context was provided for the features that were being incorporated into the application. Due to the large scale of the program, the lack of comments made it difficult to understand the software design choices that allowed the program to obtain total functionality. To alleviate this issue, comment headers were included at the top of each Java class to summarize the functional components that are presented within the code and to explain how these components are perceived by the users.

The employment of strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science can also be seen in the implementation of the newly created Permissions and Security Questions activities. Now, when creating an account, users are instructed to answer three security questions that can be recalled at a later date to access their account if their password is forgotten. Each question is represented within the database as three columns within the user account table and are recalled in the corresponding Java class as three new variables. The addition of this feature allows users to interact with the program with more confidence as human errors are now accounted for and each account is protected with a heightened level of security. Therefore, a collaborative environment between the users and the program is fostered since the enhancements made to the program’s database support the storage of clean and usable data that can be easily retrieved and presented in a timely fashion.

Within the artifact three enhancement, the ability to design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound, and appropriately adapted to specific audiences and contexts was showcased. This skill is demonstrated through the incorporation of a notification switch that allows users to determine whether they would like to receive notifications on an individual event basis. While the majority of the Event Tracker application exists in the form of text dialog in order to convey pertinent information back to the user, the implementation of a switch provided an opportunity to diversify the layout of the event information activity and to highlight a predominant feature that the application offers. Additionally, the result of the user’s decision on whether they would like to be notified is then converted to text once all event information has been entered in order to communicate information in a clearer and more stylistically uniform manner. Thus, both visual and written communications were considered with the implementation the notification switch. 

### Reflection 
While enhancing the CS-360 Event Tracker mobile application, I learned  how to independently manipulate characteristics of the program’s database without the utilization of external resources. The original creation of this application was one of the most difficult final projects I had worked on during my computer science program at SNHU and I did not fully understand the reasoning behind many of the lines of code that were used within the database. When taking CS-360, I needed to spend numerous hours analyzing textbook examples just so I could meet the expectations within the rubric. However, while the code I implemented was generally correct, I more or less was following patterns that existed within previous classroom examples and putting together different lines of code like a puzzle until I received the output I wanted. Before diving into the enhancements for this project, I spent time going through every program file and reading the contents of each method to understand what every line of code was intended to accomplish. I also utilized breakpoints while running the program so I could clearly understand what was being accomplished. By taking time to learn how and why the program was able to correctly operate, including my planned enhancements became an easier task.

When developing the new features that were to be included within the enhancement of the Event Tracker application, the greatest challenge I faced was implementing the ability to delete events. The reason as to why this task was difficult is because of my original decision to separate the tables of “event” and “event information.” The contents of the “event” table simply include the event’s name, update time, and the username that the event was created under. However, the event information table includes the actual logistics of the event that the user must answer such as the event’s date, time, and additional notes. This decision made deleting the event in its entirety, the related content in both the event and event information tables, rather difficult. This situation was made worse by the fact that the java activity that allowed for the user to delete or edit event information did not need to obtain data from the event table and thus it had not yet been declared. Eventually, my solution to these difficulties was creating tables in the database, getEvent and deleteEvent, to retrieve a matching event from the existing list in the user’s possession and then passing that retrieved event to be removed from the database.  



